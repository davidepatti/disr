\documentclass[final,journal,letterpaper]{IEEEtran}
%\IEEEoverridecommandlockouts

%------------------------------------------------------------------------------

\usepackage{cite}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage{cite}
\usepackage{balance}
\usepackage{float}
\usepackage{threeparttable}

\usepackage{mathptmx}
\usepackage[scaled=.90]{helvet}
\usepackage{courier}

\usepackage{listings}
\usepackage{listings}
\lstset{
   language=C,
   basicstyle=\small,
   keywordstyle=\bfseries,
   identifierstyle=\ttfamily,
   stringstyle=\ttfamily,
   numbers=left,
   numberstyle=\tiny,
   stepnumber=1,
   numbersep=-5pt,
   showstringspaces=false
%   frame=single %trbl%
}

\usepackage[normalem]{ulem}

%------------------------------------------------------------------------------

\newcommand{\etal}{\emph{et al.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\etc}{\emph{etc.}}

%------------------------------------------------------------------------------

\begin{document}

%------------------------------------------------------------------------------

\title{A Distributed Segment-based Approach for Topology-agnostic
Routing in Self-Assembled Nano Networks} 

\author{
%  \IEEEauthorblockN{a} \IEEEauthorblockA{Affiliation3\\ email3} \and
%  \IEEEauthorblockN{b} \IEEEauthorblockA{Affiliation2\\ email2} 
  
  }

\maketitle

%------------------------------------------------------------------------------

\begin{abstract}
In this paper we present DiSR, a first effort for a distributed
segment-based approach to routing in a nano-scale topology agnostic
scenario based on DNA self-assembly. The main aim is exploiting the
already-proven qualities of segment-based routing without neither requiring a
topology graph as input, nor needing a centralized algorithm to
discover and configure network paths. Our contribution is not to find
the optimal segments choice, but introducing an approach that can
actually work in such complex, irregular and large sized topologies.
After describing the conceptual elements and the execution model of DiSR,
we use the opensource Nanoxim tool to show some quantitive
comparisons to demonstrate how DiSR still maintains segment-based
qualities while avoiding a centralized tree-based broadcasting and the
usage of expensive virtual channels mechanisms.
\end{abstract}

%------------------------------------------------------------------------------
%\IEEEkeywords{...}

\begin{IEEEkeywords}
Nanotechnology, DNA, Self-assembly, Routing
\end{IEEEkeywords}
%------------------------------------------------------------------------------

\section{Introduction and Motivation}
Exploring long term alternatives to the CMOS technology is gaining
more and more revelance as the scaling trend of such devices keeps
introducing new challenges. Power density, defect tolerance, testing
costs and wire delays are only a few of the many critical aspects
involved~\cite{}. While software parallelism and multicore
approaches~\cite{TODO} are partially mitigating the impact on
performances, it is likely that the growing computing demand will
eventually need even more radical architectural modifications and new
paradigms in order to address the computer design issues of the next
decades.

In the last years, Self-assembled nanoscale architectures~\cite{TOOD}
are emerging as a promising technology due their tera/peta scale of
integration, defect tolerance tolerance and huge potential computing
capabilities~\cite{TODO}. These technologies are certainly still at
their early stage of development, however different laboratory demos and
prof-of-concepts architectures have been presented~\cite{TODO}.
The main idea behind this approach is to exploit the physical regularity and
stabiliy of DNA sequences in order to create a scaffold onto which
nano-devices (e.g. nanowires and nanotubes~\cite{TODO}) can be
attached. This can be achieved by designing approapriate complementary DNA tags for
each terminal to be placed, so that a nano device will be attached
only where its own DNA tag matches a complementary tag on the DNA grid
scaffold.

A detailed description of the chemical properties involved is far beyond
the scope of this paper (see also~\cite{}), so we will focus on the
three main challenges that this new fabrication process introduces in Computer Design. These are:
limited node resources, large scale randomness and high defect rates.
The first aspect is directly related to the use of complementary DNA
tags in order to place circuit components. In a traditional CMOS
process the complexity is introduced using a photolithography mask, so that larger
circuits require larger masks; instead in self-assembly this
complexity is achieved increasing the number of unique DNA tags, since
more tags means having more control on component placement. Ideally,
by specifying a single different tag for each nano transistor terminal,
we could exactly choose where each component would be placed. But the
number of DNA symbols forming the DNA sequence is limited (sequence
of 4 nucleobases G,A,T,C) and so creating many different tags (of a
given lenght) would mean make them more similar to
each other, increasing the probability of incorrect/partial matching. Then,
limiting the need of many unique tags means putting a limited
complexity in each node. Large scale randomness and defect rates are
the other two fundaments conditions of self-assembled technology:
if, as seen, some complexity can be introduced by designing tag sequences in the
DNA grid of each node, we have no control of where each of these grids
will be placed on the whole network. Further, as a consequence, we cannot guarantee other
typical properties of regular networks, like nodes being connected to 4
neighbors, having a determined orientation and so on.

These aspects of a DNA-self assembly process lead to some important
architectural implications to be addressed when approaching to the
Computer Design: computational model must be founded on a distributed
network of small computing and storage nodes, randomly placed and
interconnected.  Proof-of-concept of such kind of computational model
can be found in~\cite{}, where instructions and data operands travel
on packets and routed using a topology-agnostic strategy that avoids
deadlock, since no particular regularity can be assumed in such
network. Altought we will assume a similar scenario as background, it
is important to underline that the proposed approach to defect
tolerance is more general and not stricly dependent on any of these
architectures.

Different works have been presented addressing the problem of topology
agnostic routing, such as~\cite{}. They show interesting
performances, but the requirement for virtual channels resources 
to avoid deadlock makes them not suitable for the particular DNA self
assembled networks we are focusing on. 
Other topology independent algorithms don't use virtual channels to
achieve deadlock freedom but turn proibitions, like~\cite{}.
Up-Down~\cite{} which exploits the creation of a spanning tree of the
topology, then placing bidirectional restrictions by avoiding a packet
to traverse the same link in both up and down directions. Should be
noticed that the hierarchical nature of this approach can lead to uneven traffic
distribution, with many packets traversing upper links (near to the
root), however this is still acceptable for classical wide area networks
topologies with a limited number of nodes.  The~\cite{} mitigates this
issue, but the whole restriction placement is still prefixed,
striclty depending on the particular root selected, thus making these
approaches not scalable for the TODO(thousands) nodes scenario of DNA
self assembled technology.

In~\cite{} authors present SR, a new approach the solves this limitation by
allowing turn restrictions to be placed locally, independently from
other restrictions. The whole network is partitioned into segments, and a
single bidirectional turn restrictions can be chosen for each
segment in order to guarantee deadlock freedom and connected networks.
This \emph{locality independence} property makes SR scalable for large-sized networks,
but its topology independency still requires the knowledge of the
network topology graph in order to find the segments. The small scale control,
random placement and connectivity features discussed above
make it impossible having such topology graph knowledge, as well as
trying to execute a centralized algorithm that uses the graph description as input.

The contribution presented in this paper is a first effort for a
Distributed Segment-based routing in nanoscale DNA based networks
(DiSR). The presented approach is not intended to discover the "optimal"
segment choice (ideally reachable with the knowledge of the whole
topology graph) but just to demonstrate a concrete model that can fit
into such complex, irregular and large sized topologies.

%------------------------------------------------------------------------------
\section{DiSR main concepts}
%------------------------------------------------------------------------------

We distinct among two different kind of data stored at each node:
local environment data (LED) and dynamic behaviour status (DBS).

\subsection{Local Environment Data (LED)}

The LED is like a snapshot of the DiSR algorithm on each node,
consisting in the following variables:

\begin{itemize}
\item{segID}:a value used to specify a segment id for the node. Depending on
the values of visited/tvisited variables below, the node can be
assigned to or candidate for a specific segment id.  
\item{visited}: a boolean value corresponding to the visited status. If visited is true
and segID is different from NULL, then segID specifies the segment id
the node belongs to. Note that a value different from NULL does not
necessarily mean the node has been assigned to some segment (e.g. when
searching starting segment is set visited by default even if not yet
assigned to any segment). When false, the node is not yet visited.
\item{tvisited}: a boolean value corresponding to the tvisited status. If
true, the node is being considered as candidate for a segment, and the
segID specifies the segment id for which the node it's candidate. When
false, the node is not currently tvisited.  
\item{link\_visited[]}: an array
of values representing information about attached links, that is, the
ID of the segment owning each link. When NULL, a link has not yet been
marked as visited. TDB: do we need to introduce some value for the
“bridge” status ? (e.g. a node connecting the terminal node of a
subnet with the starting one of another) 
\item{link\_tvisited[]}: an array of
values representing information about attached links, e.g. the ID of
the segment for which the link is candidate. When NULL, the link is
currently not tvisited.  starting: boolean, true if the node it's a
starting node for the subnet terminal:boolean, true if the node it's a
terminal node for the subnet.  subnet:the subnet the node belongs to.
If NULL, none.
\end{itemize}

\subsection{Dynamic Behaviour Status (DBS)}
In addition to the LED variables described above, further information
should be stored in order to capture the current dynamic behaviour of
the node. This is represented by the dynamic behaviour status (DBS)
variable, which strictly depends on the LED data and the events
occurring at the node. The DBS can have the following values:

\begin{itemize}
\item{FREE}: a node that has  not been yet considered  by the DiSR algorithm.
The node is not marked as visited/tvisited/terminal/starting.
\item{BOOTSTRAP}: a node which has been explicitly set as bootstrap node from
an upper layer via. This is required because a
\item{STARTING\_SEGMENT\_REQUEST} packet should be injected in order to start
the whole process.
\item{ACTIVE\_SEARCHING}: a node from which a find process of new segments has
been started and not yet cancelled or confirmed. This happens when all
the following conditions are matched: the node is marked as visited,
that is visited = TRUE 
TODO: segID is set to some value reflecting
the segment request sent there is a link that is being investigated by
the node, that is a tvisited\_link marked with the same id of the node 
\item{CANDIDATE}: a node currently candidate for belonging to some segment
with id segid, not being itself the node from which the find process
was started. The following conditions should be matched: tvisited =
true, with segID=X different from node's id.  Two links set as
link\_tvisited with id X. Let’s refer them as  links 'i' and 'j'. Then
link\_tvisited[i] was set = X when the find process from an adjacent
node reached the current node, while link\_tvisited[j] has been set to
X when the node itself started to investigate its free links for the
segment request with id X. Note that while investigating its attached
links, if the find process fails along path 'j', the current node can
investigate another free node 'k' if suitable.  
\item{CANDIDATE\_STARTING}: same as above, but the node is currently being considered as candidate
for starting segment. Two main differences: Can confirm
STARTING\_SEGMENT\_CONFIRM with the same segID when receiving a normal
SEGMENT\_REQUEST: Overwrites its status setting it to CANDIDATE for the
segID frees the links previously set as tvisited during flooding
\item{ASSIGNED}: a node for which the segment has been determined.  The
segment segID attribute value is set to some id X different from NULL.
The visited value is true NOTE: an ASSIGNED state is a quick temporary
state, since it becomes ACTIVE\_SEARCHING if a not (visited/tvisited)
link is suitable for searching new segments (see next\_visited
procedure on paper) 
\item{PROCESSED}: a node which should take no other
action, since all its links have been investigated. 
\end{itemize}

\subsection{Packets types Required}
TODO: a lot of description is already present elsewhere, make this
section smaller...

\begin{itemize}
\item{SEGMENT\_REQUEST}: used to search candidates for a segment (not the
first of the subnet, managed separately as a starting segment).

\item{SEGMENT\_CONFIRM}: used to create a segment. When received, if the node
status is tvisited with a segID corresponding to the one indicated in
the packet, the node learns to belong to the segment associated to the
id. Further, it should forward this packet to the link where the
original SEGMENT\_REQUEST packet came from, so that all candidate nodes
can learn the segment id they belong to. The following LED shoud be
updated: The state of the node changes from tvisited to visited.  the
link\_tvisited previously set with the segID should be invalidated the
link\_visited variable associated to the incoming confirm should be set
as segID. Note that if the request was flooded across different links,
the link\_visited variable associated to the other paths shouldn’t be
set.  the link\_visited variable associated to the link from which the
request was originated should be set segID

\item{STARTING\_SEGMENT\_REQUEST}: the request for the first segment of a
subnet should be differentiated since all nodes (except the starting
one) must forward the packet using a flooding mechanism. This is
necessary since the request packet must reach the starting node, which
is the only node marked as visited. As stated elsewhere, it should
remembered that the first segment of each subnet it's  a loop that
beginning/ending on the starting node.


\item{SEGMENT\_CANCEL}: used when the process of searching a segment along a
certain path fails. When a node discovers that the path that includes
the node itself is no more suitable, a SEGMENT\_CANCEL is sent back
across the link from which the SEGMENT\_REQUEST was received.  Possible
reasons for that: The node it’s already candidate for another segment
The node it’s free but can’t find a free link (according the
cyclelinks timeout) The node it’s tvisited for the same request id,
previously forwarded that request along some free direction, but now
it’s receiving a a cancel request and has no more free links

\end{itemize}

\section{Draft of DiSR Execution Model}

\subsection{Creating the starting segment}

\begin{itemize}

\item{Injecting request}: all nodes have status FREE, except for a
“bootstrap node” with status BOOTSTRAP, set by some signal from an
upper layer via. This bootstrap node sets itself as “visited” and
changes its status to ACTIVE\_SEARCHING, sending a
STARTING\_SEGMENT\_REQUEST across one of its not (visited/tvisited)
links and.  

\item{Flooding}: Each node receiving a STARTING\_SEGMENT\_REQUEST,
if not (visited/tvisited),  forwards  to the attached links that are
not already marked as visited/tvisited using a flooding mechanism.
Each of these links is then marked as tvisited with the segment id
associated to the packet. Note that a node that has already received a
STARTING\_SEGMENT\_REQUEST packet can simply ignore further packets
associated to the same request, since has already contributed to the
flooding. Note also that each of these packets has a max\_segment\_hops
field to prevent packets from travelling undefinitively.  

\item{setup of the starting-segment}: when this STARTING\_SEGMENT\_REQUEST packet reaches
the starting node (from a different link, of course), the starting
segment is found. Then the starting node sends back a SEGMENT\_CONFIRM
packet with the same id along the link from which it received the
STARTING\_SEGMENT\_REQUEST. Each node do same by changing its own status
from tvisited to visited. So the confirmation packet is sent back from
node to node and the starting segment is created. 

Note: A node knows to be tvisited due a  STARTING\_SEGMENT\_REQUEST.
Then, when receiving a SEGMENT\_REQUEST for other (not the starting)
segment, simply knows to cancel the tvisited status of the node and
its links, since if a segment arrived it means that a starting segment
has already been found a there’s no need to keep the tvisited status
for those broadcast status. What happens to nodes not receiving these
segment request? they simply remain tvisited and after a timeout reset
their state as free. But they could also remain tvisited for the
starting segment, since this doesn’t affect their behaviour for future
segment requests.  

failure: TODO should we handle this case ? i.e.
marking as terminal ?

\end{itemize}

\subsection{Finding other segments}

\begin{itemize}
\item{Injecting request}: A node in the ASSIGNED state can initiate a search for a
segment, by sending a SEGMENT\_REQUEST with an across one of its free
links. Note that, since this is not the starting segment, in this case
the packet should not reach the initiator, but just another visited
node

\item{setup of the segment}: The find process is successfull when a visited
node receives the SEGMENT\_REQUEST packet. Then, a SEGMENT\_CONFIRM is
sent back along the path that originated the request.  Failing while
searching a segment: a node received a SEGMENT\_REQUEST packet but
matched one of the following conditions: the node is free but has no
more suitable free links (can’t forward the SEGMENT\_REQUEST) the node
is tvisited candidate for another find process the request packet
exceeded the max\_segment\_hops limit.  In all these cases the node
sends back a SEGMENT\_CANCEL along the proper link modifying its state
to free. Each of the subsequent nodes will forward this SEGMENT\_CANCEL
only if no more free links can be explored starting from them.
\end{itemize}


\subsection{Intra-node vs Inter-node parallelism}
In the processes described above, we assumed that each node in the
READY\_SEARCHING state can start a find segment process by injecting a
SEGMENT\_REQUEST. However, a more accurate decision when defining DiSR
should be made in order to decide whether or not the node must
actually perform this action. 
The point above is is strictly related to the general question: which
level of “parallelism” should we allow in DiSR ? The adopted approach
is that, although the nature of DiSR itself is intrinsicly parallel,
the use of parallelism makes things work in a more complex way. In
other words, DiSR is parallel when needed, but it does not exploit
parallelism as an “improving feature”. When not needed, things should
be serialized. For example: when a node is “ready searching” could
start several find segment process associated to the same segment, one
for each free link. But serializing this by investigating the free
links in order could be a simplest solution. We refer to this saying
that we avoid intra-node parallelism.  Note that while intra-node
parallelism can be avoided, trying to avoid inter-node parallelism
could be more complex than allowing the parallelism itself. Imagine
for example the effort of trying to coordinate nodes so that an unique
finding node process is actually running in the whole subnet. Thus, in
contrast to the intra-node parallelism, the inter-node parallelism is
a structural property of the DiSR algorithm and should not be avoided.
%------------------------------------------------------------------------------

\section{Detailed Node behaviour Model}

%TODO: add state machines

% TODO: fix, move elsewhere or delete
Assumption: when discussing of visited/tvisited nodes, we are assuming
with an id corresponding to the same subnet. Nodes involved in other
subnet processes can simply ignore these packets. (TBD: formalize more
clearly in which cases inter-subnet packets must be ignored, probably
this happens most of the times, but in some cases, e.g. when a
terminal node is found, some kind of communication packets are needed
in order to crearte the bridge between two subnets.) 

\subsection{Receiving a STARTING\_SEGMENT\_REQUEST}

When a node receives a STARTING\_SEGMENT\_REQUEST, with id = X,  there
are the following cases:

\begin{itemize}
\item The node is visited with the same segID = x, that is it was the
initiator of the request (set visited by definition): a first segment
was found and should be confirmed sending back a SEGMENT\_CONFIRM
packet.  

\item The node is tvisited, with the same segID of the packet: due
the flooding mechanism, another starting segment packet reached a node
which was previously marked as tvisited from the same starting segment
search process. Since the node is tvisited with the same id, it means
that it already accomplished in the task of propagating that kind
packets, thus can simply ignore the event thrashing the packet.  If
the node it's not visited/tvisited: it should set itself as tvisited
and forward the packet along its free links, using flooding. TBD: how
the status should be changed ? depend on the flooding mechanism. Note
that these links don’t include the link from which the request was
received.  

\item The node it's visited, with different id in the packet.
CHECK:  it is not the initiator of the starting segment request, but
is already assigned to some segment!? assuming again we are discussing
of nodes belonging to the same subnet, this should NOT happen, since
the only visited node of the subnet should be the initial node from
which the STARTING\_SEGMENT\_REQUEST originated. Note again that we are
assuming that if the the node is visited or tvisited with the id of
another subnet can simply ignore the request.  The node it's tvisited
but it's not the initiator of the request (different id): same as
above, if we are assuming nodes of the same subnet, this shouldn’t
happen. If the node is of another subnet, can simply ignore the event.

\end{itemize}

\subsection{Receiving a SEGMENT\_REQUEST}
When a node receives a SEGMENT\_REQUEST, the are the following cases:

\begin{itemize}
\item The node is visited (and belongs to the same subnet): a segment was
found and it should be confirmed sending back a SEGMENT\_CONFIRM
packet.  

\item The node is tvisited: it should discard the packet sending
back a SEGMENT\_CANCEL 

\item The node it's not visited/tvisited and has free
links: it marks itself as tvisited and forwards the SEGMENT\_REQUEST
(one request at time) to each of its free links, according to some
ordering

\item NOTD: the difference between confirming a STARTING\_SEGMENT\_REQUEST
and confirming a SEGMENT\_REQUEST is that in the first case the node
itself it's included in the segment , while in the second case the
receiving node DOES NOT belong to the segment found. The motivation is
that in the second case the node was already marked as visited because
of being assigned to some segment found before, while in the
starting-segment case, by definition, the first segment of a subnet
begins with the starting node, which is marked as visited by the SR
algorithm when searching for the first (starting) segment. Remember
that the first segment of a subnet is a loop beginning with the
starting node. 
\end{itemize}

\subsection{Receiving a SEGMENT\_CANCEL}
When a node receives a SEGMENT\_CANCEL packet it means that searching
for a segment along that path was unsuccessful. But if the node still
has other free links to try, it should forward a SEGMENT\_REQUEST to
the next link (next according to some internal ordering). So a node
forwards back the SEGMENT\_CANCEL packet along the link that originated
the SEGMENT\_REQUEST packet ONLY when there are no more free links to
try. If this is the case, the node modifies its status from tvisited
to free and fordwards the SEGMENT\_CANCEL packet to the link from which
the request was received. The process stops when the SEGMENT\_CANCEL
packet reach the starting node that originated the request.

\section{Simulation environment and Results}

In this section we will test the proposed DiSR approach to demonstrate
its effectiveness from two different perspectives:
\begin{itemize}
\item Against the serial segment based approach SR, to evaluate if 
its qualities are still preserved in the new nano-scale distributed scenario
\item Against other topology agnostic approaches based on spanning
trees and broadcasting, to measure how DiSR performs in discovering
the network structure 
\end{itemize}

\subsection{Nanoxim tool}

In order to quantitatively and qualitatively the proposed approach a
specific simulation environment has been developed, resulting in
the open source and freely available project called Nanoxim~\cite{}.
Nanoxim is a SystemC tool based on a almost rewritten
version of the Noxim Network-on-Chip simulator~\cite{}. While some
complex features have been removed (e.g. wormhole, congestion/topology
aware routing and selection strategies) new features specifically
taylored for nanoscale scenario were introduced, like the ability to simulate a random
network, the implementation of the DiSR to obtain the segment topology
and the support for defective links simulation.

%------------------------------------------------------------------------------
\subsection{Experimental setup}
The following setup parameters have been taken into account when
performing the DiSR simulation:
\begin{itemize}
\item {S}: Size of the network, intended as number of nodes (from X to Y)
\item {P}: probabily of failure, that is the probability that each
link is disconnected or not present 
\item {B}: bootstrap node, the node used from upper (e.g. microscale)
layer to inject the DiSR process

Other optimisation parameters which demostrated to improve the DiSR
results have been fixed to some good values, but are not subject to
further investigation in this initial work, where the focus is not the
optimal set of segments, but just demostrating the working mechaninsm
of the approach. These are:
\begin{itemize}
\item{cycle\_links}: 
\item{bootstrap\_immunity}:
\item{bootstrap\_timeout}:
\end{itemize}

\subsection{Evaluation Metrics and Results}
\label{sec:results}

The following metrics have been adopted:
\begin{itemize}
\item{Node coverage}: this is the fraction of non-defective node elements that
are assigned to a segment. In the ideal case, all the non defective
nodes should be assigned, so this metric is useful to show how some
disconnected node regions can negativaly impact on the whole DiSR
effectiveness.
\item{Broadcast latency}: this measures how the time required to complete the
segment assignment scale for increasing network sizes and defect rates
\item{Connectivity}:
\item{Bootstrap node effect}: this evaluates the impact of the chosen
bootstrap node on the node coverage.
\end{itemize}

Further, to evaluate how DiSR compares against the centralized segment
based algorithm, the following metrics have been adopted:
\begin{itemize}
\item {Average Path Lenght}:
\item {Average Link Weight}:
\item {Number of Segments}:
\end{itemize}

Node (Broadcast) Coverage(vs \%defective links) with different sizes:
30x30, 50x50, 80x80, 100x100, ideal. Bigger networks show similar
trends 

Broadcast latency (vs sqrt(N), with different \% defectived
links. TODO: calcolare ordine di grandezza atteso O(N), rete NxN
Effect of bootstrap node 

Qualcosa tipo Broadcast Tree properties (sez.  5.4)


\section{Implementation Issues}
\label{sec:implementation}
Althought a completed and detailed floorplan of the node is not the
focus of this work, in this section we want to give a basic idea of
which are the main elements required to support this kind of
architecture and the DiSR approach. There are three main classes of
node elements:
\begin{itemize}
\item Node-specific: components (such ALUs, memories) that are
strictly related to the node functionality and role inside a given
networks: e.g. is that a computation or storage node ?
\item Node communication:  these are elements (such as transceivers,
buffers) required to the node to communicate with its neighbors,
indepentently from node functionality and DiSR implementation
\item DiSR-specific: all the hardware, such as control logic and
configuration, required to implement the proposed DiSR approach.
\end{itemize}

\begin{figure}
  \centering
  \includegraphics[width=0.50\textwidth]{pictures/router_schematic.eps}
  \caption{Schematic of the router. Top-level view (top). Block
  implementing the routing algorithm (middle). Block implementing the
  TODO
  }
  \label{fig:schematic}
\end{figure}

Figure~\ref{fig:schematic} shows the schematic of a router for
a mesh based network topology implementing DiSR . As shown, the top level scheme of the router consists of a
set of ...

The content of a routing algorithm block is more accurately shown in
the central part of Figure~\ref{fig:schematic}. Each routing algorithm
block consists of ...

Let us now look inside the \emph{DiSR} block. A formal description of
DiSRalgorithm has already been given in Figure~\ref{alg:disr}, thus we
will focus on the architectural elements to be implemented.
	
\end{itemize}


%------------------------------------------------------------------------------

\section{Conclusions}
...

%------------------------------------------------------------------------------

\balance

\bibliographystyle{IEEEtran} 
\bibliography{bibliography}

%------------------------------------------------------------------------------

\end{document}
